# API 

## 格式化

格式化字符串中参数索引值从 1 开始，而非 0，是为了避免与 0 标志混淆。

## 标准输出流

System.out 被声明为 final，但 System.setOut() 方法却可以改变它，这是因为该方法是一个本地方法。本地方法可以绕过 Java 变量的存取控制机制。

## 克隆

在 Object 类中，clone 方法被声明为 protected，而所有类都是 Object 的子类。

为什么在自定义的类 A 中不能直接调用 anObject.clone() 呢？

对象的protected成员或构造器在声明它的包的外部，只能被负责实现该对象的代码所访问。 ——《Java语言规范》

## 断言

assert 条件:表达式

“表达式”部分的唯一目的是产生一个消息字符串。AssertionError对象并不存储表达式的值，因此，不可能在以后得到它。之所以这样，是因为，如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。

## 泛型

### 为什么限定符为 extends 而非 implements？

<T extends Superclass> 表达式表示：T subtypeOf Superclass，但不希望引入一个新关键字。

T 即可以是类也可以是接口，从子类型的角度来说，extends 更接近要表达的意思。

严格说来，使用 extends 只是一个约定。

### 限定类型分隔符为什么是 & 而不是 , ？

可指定多个限定类型，分隔符是 &，而不是逗号，因为逗号已作为多个类型变量的分隔符。如：<T, S extends Comparable & Serializable>。

### 为什么不能创建泛型数组？

因为擦除的原因，无法在元素赋值时进行类型检查，因此强制不允许。

注：可创建通配符类型数组，再进行强制类型转换。但类型不安全。

## 集合

### toArray 方法为什么不直接以 Class 为参数？ 

Collection.toArray(T[] a)  参数不是 Class 类型的，这是因为这个方法具有“双重职责”，不仅要填充已有的数组（如果足够长），还要创建一个新数组。

### Collections.sort() 为什么使用归并排序算法而非更快的快速排序？

Collections.sort()直接将所有元素转入一个数组，并使用一种归并排序的变体对数组进行排序，然后，再将排序后的序列复制回列表。

归并排序算法比快速排序要慢，但它是稳定的，即不需要交换相同的元素。

# 特性

## 自动装箱

```
Integer n = 3;
n++;
```

说明：赋值语句涉及自动装箱。要注意的是“n++”，n是Integer类型，是不可变对象，之所以可以自增是因为：编译器将自动地插入一条对象拆箱指令，然后进行自增计算，最后再将结果装箱。

## 数值文本分隔符

使用下划线作为分隔符，而不使用逗号（,）或连字符（-）作为分隔符呢？

因为这可能会引发歧义。

* 逗号，在数组初始化器中有歧义
* 连字符，与减法混淆

下划线数值文本表示法仅仅是一个源代码级别的新特性，编译器会在编译时去掉下划线，只保留原始数字。