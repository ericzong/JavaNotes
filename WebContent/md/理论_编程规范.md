# 类

## 不创建常量类

不应创建只有常量的类，即使以无法实例化的方式实现也不应该。作为类，应该既有状态，又有行为。所以，如果不得不把一堆常量集中起来管理，那么，应当把它们声明在接口中。

# 成员

## 成员访问权限应尽量严格

成员访问权限过大可能导致过度的依赖，并且更容易被人为从外部修改赋值、破坏代码逻辑、引发 Bug，因此，访问权限应尽量严格。

如果可能，成员应尽量声明为 private 的；如果需要包内共享，才应该考虑赋予包访问权限；在确认该类被继承，并且在派生类中需要继承该成员时，才考虑声明为 protected；通常，成员不应声明为 public，除非成员变量是作为常量声明，或者成员方法理应是 API 的一部分。

## 属性大小写命名与getter/setter方法

通常，建议属性名以小写字母开头，但这仅仅是建议。有的属性名以某些通常大写的词（如缩写词）开头，那么属性名也可能是大写字母开头。

但规范要求，属性名的前两个字母大小写必须一致。

> 因此，ICar是合法的，而iCar不是。但请注意，它们的getter/setter方法名是一致的，这可能导致一些工具框架出现莫名的错误。

总之，使用小写字母开头命名属性总是好的，但避免使用单个小写字母前缀。

## 纯数字状态位

不推荐使用数字来表示状态或标记，这使得可读性很差，可以使用可命名的枚举来代替。

但如果遗留系统中已经这样使用了，或者说某些情况下不得不这样使用，那么，至少应该提供一个工具方法将数字解析为可读信息。

# 方法

## 构造器“重写”

子类不必“重写”父类所有的构造器，子类中不被使用的构造器不应声明。

> 存在无用的构造器可能会使其它使用者误用，而通常这些多余的构造器由于作者的忽略很可能存在错误。

## 构造器链

尽量不显式调用父类无参构造器 super()，显式调用显得代码过于冗余。

如果本类的无参构造器“为空”，则不应在其它构造器中用 this() 调用它。

## 访问器

访问器不应返回可变对象引用，如果需要，则应该对其进行克隆（clone）。

## finalize 方法

不要依赖于使用finalize方法回收任何短缺资源，因为不确定该方法何时被调用。

System.runFinalizersOnExit(true)确保finalize方法在Java关闭前被调用，但不安全，不推荐使用。应使用Runtime.addShutdownHook添加“关闭钩”（shutdown hook）。

# 域

## protected 域

不要使用受保护的域。

# 变量

## 尽量缩小局部变量作用域

局部变量的作用域应该尽量的小。

如果一个成员变量仅仅在某个方法中被使用，那么应该考虑是否可以将其作为变量声明在该方法中，而除去成员变量的声明。

## 删除不被使用的变量

不被使用的变量应该尽早删除。
不被使用，是指没有在程序中被读取过。
但很可能由于某些原因在程序中给其赋过值，则删除时，应同时删除赋值语句。

对于局部变量和私有成员变量而言，编译器可以检查到其未被读取过，因此我们可以根据编译器警告来定位这些变量。
但是，对于非私有访问权限而言，编译器则不会检查，所以需要人为分析其使用情况。

# 继承

除非所有继承的方法都有意义，否则不要使用继承。

在覆盖方法时，不要改变预期的行为。

# 其他

## 注释

### 是否使用注释

通常，我们说精心编写的代码不言自明，不需要注释。

注意，并没有任何规范或规则说过不需要注释，但一旦达到不言自明的要求了，注释就并非必要的了。

可是，通常情况下，大多数代码并非精心编写的。这可能是由于总是不慷慨的工期，或其他什么原因。另一方面，尽管我们努力编写精美的代码，但产出的代码可能并非我们认为的那样精美。

还有一种情况是，你的客户可能提出反常逻辑的需求，这时就有必要注释说明了。



