<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>Java 基础纲要：语法</title>
<link type="text/css" rel="stylesheet" href="../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../css/fold.css"  />
<link type="text/css" rel="stylesheet" href="../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../css/highlight.css" />

<script type="text/javascript" src="../js/title.js"></script>
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>数据类型</h1>
  
  <h1>运算符</h1>
  
  <p>复合赋值运算符的隐式类型转换可能导致结果高位被“截断”。</p>
  
  <p class="next">逗号分隔符通常用于：</p>
	<ol>
	  <li>用于 for 循环控制表达式：初始化、步进</li>
	  <li>定义多个变量，但类型须相同</li>
	</ol>
  
  <h1>关键字</h1>
  
  <h2>this &amp; super</h2>
  
  <p>当 this 在构造器中时，this 代表正在初始化的 Java 对象。</p>
  <p>Java 程序允许某个方法通过“return this;”返回调用该方法的 Java 对象；但不允许直接“return super;”，
    因为 super 本身不是一个对象的引用，而只是一个指示编译器调用超类方法的特殊关键字。</p>
    
  <h2>extends</h2>
  
  <p>关键字 extends 表明正在构造的新类派生于一个已存在的类。
    已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；
    新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。
    前缀“超”和“子”来源于计算机科学和数学理论中的集合语言的术语。</p>
    
  <h2>final</h2>
  
  <p>final 修饰的实例变量或类变量的初始化时机与没有 final 修饰时类似，唯一的区别是：final 修饰时，不能仅执行默认初始化，而不显式地赋值。</p>
  <p>内部类访问的局部变量必须 final 修饰的原因：对于普通局部变量，作用域在方法内，但内部类可能产生隐式“闭包（Colsure）”，使局部变量脱离方法继续存在，即扩大作用域。</p>
  <p>类中所有的 private 方法都隐式地指定为 final 的。(?)</p>
  <p>由于 final 类禁止继承，所以 final 类中所有的方法都隐式指定为 final 的，因为无法重写它们。</p>
  
  <p>如果将一个类声明为final，只有其中的方法自动地成为final，而不包括域。</p>
  
  <p class="next">使用 final 方法的原因：</p>
  <ol>
    <li>方法锁定。以防任何派生类修改其含义</li>
    <li>效率。同意编译器将针对该方法的所有调用都转为内嵌调用</li>
  </ol>
  
  <h1>标识符</h1>
  
  <p class="next">Java 中标识符简单来说只能包含字母和数字，并不能以数字开头。
    需要说明的是，Java 中“字母”和“数字”的概念比相应的常规概念要大：</p>
  <ul>
  	<li>字母：’A’~’Z’、’a’~’z’、’_’、’$’、某种语言中代表字母的任何Unicode字符。</li>
  	<li>数字：’0’~’9’、某种语言中代表数字的任何字符。</li>
  </ul>
  
  <h1>修饰符</h1>
  
  <h1>注释</h1>
  
  <h1>流程控制</h1>
  
  <p class="next">不能在嵌套的两个块中声明同名的变量。</p>
  <div class="ext">
  	<p>C++ 中，可以在嵌套块中重新定义一个变量。内层定义的变量会覆盖外层定义。这有可能导致程序设计错误，Java 中不允许。</p>
  </div>
  
  <h2>循环</h2>
  
  <p>循环体中只包含一条局部变量定义语句时，循环体花括号不能省略，否则编译错误。</p>
  
  <p>需要标签的唯一理由：有嵌套循环存在。</p>
  
  <h2>switch</h2>
  
  <p>case 表达式必须是常量，注意 null 不是常量。</p>
  
  <p>switch 的 case 语句，由于结构清晰，可以不加花括号。但是，是否有花括号直接影响声明变量的作用域。
    如果 case 语句在块中声明变量，则变量作用域明显在块内；否则，作用域在 switch 块内，声明之后均可使用
  ——但要注意，所有使用该变量的 case 语句都必须初始化它，否则编译错误，提示局部变量未初始化。</p>
  
  <p class="next">贯穿（fallthrough），应使用 -Xlint:fallthrough 进行编译检查；如果是编程技巧造成的，应使用注解 @SuppressWarnings("fallthrough") 抑制。</p>
  <div class="ext">
  	<p>贯穿现象很容易理解，形式上说，case 分支类似标签的概念，跳转到某个分支后除非 break 出 switch，否则会顺序执行。</p>
  </div>
  
  <h1>异常处理</h1>
  
  <h1>语法糖</h1>
  
  <p>Java 中语法糖只存在于编译期，在编译器将 .java 源文件编译成 .class 字节码时，会进行解语法糖操作，还原最原始的基础语法结构。</p>

  <p>Java 语法糖包括：字符串拼接、条件编译、断言、Switch语句与枚举及字符串结合、可变参数、自动装箱/拆箱、枚举、内部类、
    泛型擦除、增强  for 循环、lambda 表达式、try-with-resources 语句、JDK10 的局部变量类型推断等等。</p>
  
</body>
</html>