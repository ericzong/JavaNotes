<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>Java 基础：语法</title>
<link type="text/css" rel="stylesheet" href="../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../css/fold.css"  />
<link type="text/css" rel="stylesheet" href="../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../css/highlight.css" />

<script type="text/javascript" src="../js/title.js"></script>
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>数据类型</h1>
  
  <h1>运算符</h1>
  
  <p>复合赋值运算符的隐式类型转换可能导致结果高位被“截断”。</p>
  
  <h1>关键字</h1>
  
  <p>当 this 在构造器中时，this 代表正在初始化的 Java 对象。</p>
  <p>Java 程序允许某个方法通过“return this;”返回调用该方法的 Java 对象；但不允许直接“return super;”，
  super 关键字本身并没有引用任何对象，甚至不允许直接将 super 当成一个引用变量使用。</p>
  
  <h1>标识符</h1>
  
  <h1>修饰符</h1>
  
  <h2>访问修饰符</h2>
  
  <p>final 修饰的实例变量或类变量的初始化时机与没有 final 修饰时类似，唯一的区别是：final 修饰时，不能仅执行默认初始化，而不显式地赋值。</p>
  <p>内部类访问的局部变量必须 final 修饰的原因：对于普通局部变量，作用域在方法内，但内部类可能产生隐式“闭包（Colsure）”，使局部变量脱离方法继续存在，即扩大作用域。</p>
  <p>类中所有的 private 方法都隐式地指定为 final 的。(?)</p>
  <p>由于 final 类禁止继承，所以 final 类中所有的方法都隐式指定为 final 的，因为无法重写它们。</p>
  
  <h2>非访问修饰符</h2>
  
  <h1>注释</h1>
  
  <h1>流程控制</h1>
  
  <p>循环体中只包含一条局部变量定义语句时，循环体花括号不能省略，否则编译错误。</p>
  
  <h1>异常处理</h1>
  
</body>
</html>