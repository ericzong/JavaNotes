<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>Java 基础纲要：基本概念</title>
<link type="text/css" rel="stylesheet" href="../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../css/fold.css"  />
<link type="text/css" rel="stylesheet" href="../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../css/highlight.css" />

<script type="text/javascript" src="../js/title.js"></script>
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>概述</h1>
  <p>Java 包括 Java 语言和 Java 平台。
  	Java 语言指的是通常意义上的编程语言，而 Java 平台是为其提供运行时环境的软件。</p>
  <p>Java 语言是静态类型、强类型、面向对象的解释型语言。</p>
  <div class="ext">
  	<p>静态类型语言主要强调变量类型是在编译期确定的。</p>
  	<p>强类型语言指强制类型定义，变量需先定义后使用。</p>
  </div>
  <p>Java 虚拟机（JVM）用以执行 Java 程序，但 JVM 不能直接解释 Java 源文件，需要先用编译器把源文件转换为类文件，
  	再由 JVM 把类文件形式的代码链接起来并执行。</p>
  <div class="ext">
  	<p>用编译原理术语讲，字节码是一种中间语言（IL）形态。</p>
  	<p>统一的类文件格式定义是连接 Java 语言和平台的纽带。</p>
  	<p>Java 是解释型语言，所谓的编译器 javac 不同于 gcc，仅仅是一个将 Java 源码生成类文件的工具。
  	Java 体系中真正的编译器是 JIT。动态编译即是指 JIT 的运行时编译，而不是构建时创建类文件的过程。</p>
  </div>
  <p>还有很多基础概念是需要了解的，这里不一一赘述了。</p>
  <div class="ext">
  	<p class="next">还应该了解：</p>
  	<ul>
  		<li>Java SE、Java EE、Java ME 分别代表什么？</li>
  		<li>JDK 和 JRE 有什么区别和联系？</li>
  		<li>Java 平台不只能运行 Java 语言这一种语言。</li>
  	</ul>
  </div>
  
  <h1>面向对象的概念</h1>
  
  <p>对象是某些相关概念在代码级别的抽象。</p>
  <p>抽象最好的定义是：放大本质，去掉无关的内容。</p>
  
  <p>封装：对系统中的其他对象，隐藏所有不必要的细节。</p>
  <p>访问权限控制=具体实现隐藏</p>
  <p>数据、方法包装进类 + 具体实现隐藏 = 封装</p>
  
  <p>用继承表达行为间的差异，用字段表达状态上的变化。</p>
  
  <p>多态 = 动态绑定/运行时绑定/后期绑定</p>
  <p>多态作用：消除类型之间的耦合关系。</p>
  <p>绑定：将一个方法调用同一个方法主体关联起来。</p>
  <p>前期绑定：在程序执行前进行绑定。</p>
  <p>后期绑定：在运行时根据对象类型进行绑定。</p>
  <p>Java 中除了 static 方法和 final 方法（包括 private 方法）之外，其他所有方法都是后期绑定。</p>
	
	<h2>构造器</h2>
	
	<p>new 表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。</p>
  <p>构造器是强制重载方法的一个原因。</p>
  <p>系统在编译阶段会为内部类构造器增加一个外部类类型的第一参数。</p>
  <p>在构造器内唯一能够安全调用的方法是基类中的 final 方法。</p>
  
  <h2>变量</h2>
  
  <div class="tree">
    <ul>
      <li>
        <a>变量</a>
        <ul>
          <li>
            <a>成员变量</a>
            <ul>
              <li><a title="静态变量">类变量</a></li>
              <li><a title="非静态变量">实例变量</a></li>
            </ul>
          </li>
          <li>
            <a>局部变量</a>
            <ul>
              <li><a>方法形参</a></li>
              <li><a>方法内局部变量</a></li>
              <li><a>代码块内局部变量</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </div>
  
  <p class="next">Java 不区分变量声明与定义。</p>
  <div class="ext">
    <p>C 和 C++ 区分变量的声明与定义。如：int i = 1; 是一个定义，而 extern int i; 是一个声明。</p>
  </div>
  
  <p>定义成员变量时，必须采用合法的前向引用，同类型成员变量间引用有顺序，但实例变量总可以引用类变量。</p>
  
  <h3>初始化</h3>
  
  <p>无法阻止自动初始化的进行，它将在构造器被调用之前发生。</p>
  <p>即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。</p>
  <p class="next">实例变量初始化时机：</p>
  <div class="ext">
    <ol>
      <li>定义时</li>
      <li>非静态初始化块内</li>
      <li>构造器中</li>
    </ol>
    <p>说明：编译后，前两项的初始化语句都将提取到构造器中，并位于构造器所有语句之前，且保持源码中的顺序。</p>
  </div>
  <p class="next">类变量初始化时机：</p>
  <div class="ext">
    <ol>
      <li>定义时</li>
      <li>静态初始化块内</li>
    </ol>
    <p>说明：编译后，都将提取到静态初始化块中，两者保持源码中的顺序。</p>
  </div>
  
  <p class="next">线程访问类变量的4种情况：</p>
  <div class="ext">
  <ol>
    <li>未初始化类：当前线程初始化</li>
    <li>当前线程正初始化类：递归请求</li>
    <li>其他线程正初始化类：暂停</li>
    <li>已初始化类：得到 field 值</li>
  </ol>
  </div>

  <h3>常量</h3>
  <p class="next">当 final 变量本质上相当于一个直接量/宏变量时，编译器会执行“宏替换”。一个变量成为常量的条件是：</p>
  <div class="ext">
  <ol>
    <li>final 修饰</li>
    <li>声明时赋值</li>
    <li>基本数据类型或字符串</li>
    <li>赋值表达式为字面量/基本算术运算表达式/字符串连接运算</li>
    <li>赋值表达式没有访问普通变量和调用方法</li>
  </ol>
  </div>
  
  <h2>方法</h2>

  <p>协变返回类型：在派生类中重写方法可以返回基类方法的返回类型的某种派生类型。</p>
  
  <p>如果实参类型小于形参类型，实参类型将会被提升。char 略有不同，如果无法找到恰好接受 char 参数的方法，就会把 char 直接提升至 int 型。
  如果实参类型大于形参类型，将会进行窄化转换。</p>

  <h2>类型</h2>
  
  <p class="next">一个 Class 对象实际上表示的是一个类型，而这个类型未必一定是一种类。</p>
  <div class="ext">
  	<p>例如，int不是类，但int.class是一个Class类型的对象。</p>
  </div>
  
  <p>instanceof 运算符的左右操作数，以及类型强转时原类型与目标类型之间，要求在同一继承体系的同一分支上，否则编译错误。</p>
  
  <p>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</p>
  
  
</body>
</html>