<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>Java 基础纲要：常用 API</title>
<link type="text/css" rel="stylesheet" href="../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../css/fold.css"  />
<link type="text/css" rel="stylesheet" href="../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../css/highlight.css" />

<script type="text/javascript" src="../js/title.js"></script>
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>字符串</h1>
  
  <p>当能进行编译时优化时，String 使用“+”拼接的性能将比 StringBuilder.append() 更好。</p>
  
  <h1>数字</h1>
  
  <p>Integer 默认缓存了 -128~127 的对象，
    通过设置 JVM 启动参数 
    -Djava.lang.Integer.IntegerCache.high=n 
    或
    -XX:AutoBoxCacheMax=n
    可以设置。</p>
  <p>关于 Integer 的一个长期漏洞是：通过反射可以恶意修改 Integer 的 cache 属性，导致得到错误的装箱结果。</p>
  <div class="ext">
    <p>从 Java 9 开始，该修改限制更为严格。openjdk11 的运行情况来看，会有警告信息告知该修改，并说明未来将不允许此修改。</p>
  </div>
  
  <h1>数组</h1>
  
  <p>所有数组均是可克隆的，即包含一个 public 的 clone 方法。</p>
  
  <h1>集合</h1>
  
  <p>Java 用迭代器而不是 Collection 来表达容器之间的共性，但两者绑定到了一起，因为实现 Collection 就意味着需要提供 iterator() 方法。</p>
  <p>应该将 Java 迭代器认为是位于两个元素之间。当调用 next 时，迭代器就超过下一个元素，并返回刚刚越过的那个元素的引用。</p>
  
  <p>对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。set 操作不被视为结构性修改。
    可以将多个迭代器附加给一个链表，所有的迭代器都调用 set 方法对现有结点的内容进行修改。</p>
  <p>LinkedList.get()方法做了微小的优化：如果索引大于size()/2就从列表尾端开始搜索元素。</p>
  
  <p>keySet 既不是HashSet，也不是TreeSet，而是实现了Set接口的某个其他类的对象。</p>
  <p>当对键的唯一引用来自散列表条目时，WeakHashMap将与垃圾回收器协同工作一起删除键/值对。WeakHashMap使用弱引用（weak references）保存键。</p>
  
  <h1>IO</h1>
  
  <h2>FileChannel</h2>
  
  <p>FileChannel 是一个抽象类，不能实例化。需要调用 FileInputStream、FileOutputStream、RandomAccessFile
  的 getChannel() 方法获取其实例。</p>
  <p>FileChannel 可以为文件加锁，当且仅当该管道是可写的。</p>
  
  <h1>其他</h1>
  
  <p>Comparable.compareTo() 应该是反对称的，即 x.compareTo(y) 和 y.compareTo(x) 返回数值应具有相反符号或同时抛出异常。</p>
  <p>如果存在这样一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个compareTo方法，并将这个方法声明为final。</p>
  
</body>
</html>