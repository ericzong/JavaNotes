<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title></title>
<link type="text/css" rel="stylesheet" href="../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../css/tree.css">

<script type="text/javascript" src="../js/title.js"></script>
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>理论</h1>
  
  <p>对象是某些相关概念在代码级别的抽象。</p>
  <p>抽象最好的定义是：放大本质，去掉无关的内容。</p>
  <p>封装：对系统中的其他对象，隐藏所有不必要的细节。</p>
  
  <p>访问权限控制=具体实现隐藏</p>
  <p>数据、方法包装进类 + 具体实现隐藏 = 封装</p>
  <p>用继承表达行为间的差异，用字段表达状态上的变化。</p>
  
  <h1>修饰符</h1>
  
  
  <h1>关键字</h1>
  
  <h2>this &amp; super</h2>
  <p>当 this 在构造器中时，this 代表正在初始化的 Java 对象。</p>
  <p>Java 程序允许某个方法通过“return this;”返回调用该方法的 Java 对象；但不允许直接“return super;”，
  super 关键字本身并没有引用任何对象，甚至不允许直接将 super 当成一个引用变量使用。</p>
  
  <h2>final</h2>
  <p>final 修饰的实例变量或类变量的初始化时机与没有 final 修饰时类似，唯一的区别是：final 修饰时，不能仅执行默认初始化，而不显式地赋值。</p>
  <p>内部类访问的局部变量必须 final 修饰的原因：对于普通局部变量，作用域在方法内，但内部类可能产生隐式“闭包（Colsure）”，使局部变量脱离方法继续存在，即扩大作用域。</p>
  <p>类中所有的 private 方法都隐式地指定为 final 的。(?)</p>
  <p>由于 final 类禁止继承，所以 final 类中所有的方法都隐式指定为 final 的，因为无法重写它们。</p>
  
  <h2>static</h2>
  
  <h1>数据类型</h1>
  <p>复合赋值运算符的隐式类型转换可能导致结果高位被“截断”。</p>
  
  <h1>语法</h1>
  <p>循环体中只包含一条局部变量定义语句时，循环体花括号不能省略，否则编译错误。</p>
  <p class="bold">逗号分隔符</p>
  <div class="ext">
    <ol>
      <li>用于 for 循环控制表达式：初始化、步进</li>
      <li>定义多个变量，但类型须相同</li>
    </ol>
  </div>
  <p>需要标签的唯一理由：有循环嵌套存在。</p>
  
  <h1>类型</h1>
  
  <h2>说明</h2>
  <p>类是对象，所有类都是 Class 实例。</p>
  
  <h2>构造器</h2>
  <p>即使没有显式地使用 static 关键字，构造器实际上也是静态方法。</p>
  <p>new 表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。</p>
  <p>构造器是强制重载方法的一个原因。</p>
  <p>系统在编译阶段会为内部类构造器增加一个外部类类型的第一参数。</p>
  <p class="bold">Java创建对象的方式</p>
  <div class="ext">
  <ul>
    <li>new 调用构造器</li>
    <li>Class 对象的 newInstance() 方法</li>
    <li>反序列化</li>
    <li>clone() 方法</li>
    <li>
      对于 String 及基本类型封装类
      <ul>
        <li>直接量</li>
        <li>表达式</li>
      </ul>
    </li>
  </ul>
  </div>
  
  <h2>继承</h2>
  <p>instanceof 运算符的左右操作数，以及类型强转时原类型与目标类型之间，要求在同一继承体系上，否则编译错误。</p>
  
  <h1>方法</h1>
  <p>多态作用：消除类型之间的耦合关系。</p>
  <p>多态 = 动态绑定/运行时绑定/后期绑定</p>
  <p>绑定：将一个方法调用同一个方法主体关联起来。</p>
  <p>前期绑定：在程序执行前进行绑定。</p>
  <p>后期绑定：在运行时根据对象类型进行绑定。</p>
  <p>Java 中除了 static 方法和 final 方法（包括 private 方法）之外，其他所有方法都是后期绑定。</p>
  
  <p class="bold">使用 final 方法的原因</p>
  <div class="ext">
    <ol>
      <li>方法锁定。以防任何继承类修改其含义</li>
      <li>效率。同意编译器将针对该方法的所有调用都转为内嵌调用</li>
    </ol>
  </div>
  <p>在构造器内唯一能够安全调用的方法是基类中的 final 方法。</p>
  
  <p>协变返回类型：在派生类中重写方法可以返回基类方法的返回类型的某种派生类型。</p>
  
  <p>如果实参类型小于形参类型，实参类型将会被提升。char 略有不同，如果无法找到恰好接受 char 参数的方法，就会把 char 直接提升至 int 型。
  如果实参类型大于形参类型，将会进行窄化转换。</p>
  
  <h1>变量</h1>
  
  <h2>分类</h2>
  <div>
  <div class="tree">
    <ul>
      <li>
        <a href="#">变量</a>
        <ul>
      	  <li>
      	    <a href="#">成员变量</a>
      	    <ul>
      	      <li><a href="#" title="静态变量">类变量</a></li>
      	      <li><a href="#" title="非静态变量">实例变量</a></li>
      	    </ul>
      	  </li>
      	  <li>
      	    <a href="#">局部变量</a>
      	    <ul>
      	      <li><a href="#">方法形参</a></li>
      	      <li><a href="#">方法内局部变量</a></li>
      	      <li><a href="#">代码块内局部变量</a></li>
      	    </ul>
      	  </li>
        </ul>
      </li>
    </ul>
  </div>
  </div>
  
  <h2>初始化</h2>
  <p>无法阻止自动初始化的进行，它将在构造器被调用之前发生。</p>
  <p>即使谜题定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。</p>
  <p class="bold">实例变量初始化时机</p>
  <div class="ext">
    <ol>
      <li>定义时</li>
      <li>非静态初始化块内</li>
      <li>构造器中</li>
    </ol>
    <p>说明：编译后，前两项的初始化语句都将提取到构造器中，并位于构造器所有语句之前，且保持源码中的顺序。</p>
  </div>
  <p class="bold">类变量初始化时机</p>
  <div class="ext">
    <ol>
      <li>定义时</li>
      <li>静态初始化块内</li>
    </ol>
    <p>说明：编译后，都将提取到静态初始化块中，两者保持源码中的顺序。</p>
  </div>
  
  <p class="bold">线程访问类变量的4种情况</p>
  <div class="ext">
  <ol>
    <li>未初始化类：当前线程初始化</li>
    <li>当前线程正初始化类：递归请求</li>
    <li>其他线程正初始化类：暂停</li>
    <li>已初始化类：得到 field 值</li>
  </ol>
  </div>
  
  <h2>常量</h2>
  <p>当 final 变量本质上相当于一个直接量/宏变量时，编译器会执行“宏替换”。一个变量成为常量的条件是：</p>
  <div class="ext">
  <ol>
    <li>final 修饰</li>
    <li>声明时赋值</li>
    <li>基本数据类型或字符串</li>
    <li>赋值表达式为字面量/基本算术运算表达式/字符串连接运算</li>
    <li>赋值表达式没有访问普通变量和调用方法</li>
  </ol>
  </div>
  
  <h2>说明</h2>
  <p>上转型时，任何域访问操作都将由编译器解析，不是多态。</p>
  <p>所有局部变量都放在栈内存里，但引用类型变量所引用的对象则总是存储在堆内存中。</p>
  <p>定义成员变量时，必须采用合法的前向引用，同类型成员变量间引用有顺序，但实例变量总可以引用类变量。</p>
  <p>引用变量本质上只是一个指针，只要程序通过引用变量访问属性，或者通过引用变量来调用方法，该引用变量将会由它所引用的对象代替。</p>
  
  <h1>API</h1>
  <p>Java 用迭代器而不是 Collection 来表达容器之间的共性，但两者绑定到了一起，因为实现 Collection 就意味着需要提供 iterator() 方法。</p>
  
  <p class="bold">ResourceBundle 搜索顺序</p>
  <div class="ext">
    <ol>
      <li>baseName_zh_CN.class</li>
      <li>baseName_zh_CN.properties</li>
      <li>baseName_zh.class</li>
      <li>baseName_zh.properties</li>
      <li>baseName.class</li>
      <li>baseName.properties</li>
    </ol>
  </div>
</body>
</html>