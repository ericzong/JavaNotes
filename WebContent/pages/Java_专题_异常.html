<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>Java 专题：异常</title>
<link type="text/css" rel="stylesheet" href="../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../css/highlight.css" />

<script type="text/javascript" src="../js/title.js"></script>
<script type="text/javascript" src="../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>

 <h1>概述</h1>
 
  <p>异常（exception），该术语是异常事件（exceptional event）的简称。
  异常是一个事件，它发生在程序执行过程中，扰乱程序指令的正常流程。</p>
  <p>异常对象（exception object），发生错误的方法创建，包含错误信息，包括其类型和发生错误时的程序状态。</p>
  <p>创建一个异常对象并将其交由运行时系统（runtime system）处理，这被称为抛出异常（throwing an exception）。</p>
  
  <h1>分类</h1>
  
  <div class="tree">
    <ul>
      <li>
        <a>Throwable</a>
        <ul>
          <li>
            <a>Error</a>
          </li>
          <li>
            <a>Exception</a>
            <ul>
              <li>
                <a>RuntimeException</a>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </div>
  
  <p>异常分为两大类：受检（checked）异常和非受检（unchecked）异常。</p>
  <p>非受检异常包括：错误（Error）和运行时异常（RuntimeException）。与非受检异常对应，其他所有异常都是受检异常。</p>
  
	<h1>语法</h1>
	
	<pre class="code"><code class="java">
try
{
    // 可能抛出异常的代码
}
catch(ExceptionType name)
{
    // 异常处理
}
catch(ExceptionType2 name)
{
    // 异常处理
}
finally
{
    // 无论是否异常均会执行的代码，如资源回收和释放等
}</code></pre>

  <p class="next">Java 7加入多重捕获（multicatch）语法：</p>
  <pre class="code"><code class="java">
catch(ExceptionType | ExceptionType2 ex)
{
} </code></pre>

  <p class="next">Java 7还加入了Try-with-resources（TWR）语法，用以管理自动关闭的资源：</p>
  <pre class="code"><code class="java">
try(AutoCloseableImp auto = ...)
{
} </code></pre>
    
  <h1>新特性</h1>
  
  <h2>多重异常捕获（multicatch）</h2>
  
  <p>多重catch子句可捕获的异常是表示其异常参数类型的并集中的类型。</p>
  <p>实际上，多重异常捕获是编译器把捕获多个异常的catch子句转换成了多个catch子句，在每个catch子句中捕获一个异常。</p>
  <p>多重异常捕获catch子句中异常参数的具体类型是所有列出异常在类继承层次结构上的最小祖先类。
  因为所有异常都是Exception类的后代，所以这样一个最小的上界总是会存在的。</p>
  <p>多重异常捕获时，异常变量有隐式的final修饰，因此catch子句内不能对异常变量重新赋值。
  过渡阶段最好显式地使用final修饰异常变量，以使语意明确。</p>
  
  <h2>Try-with-resources（TWR）</h2>
  
  <p>try语句中声明的资源类型都要实现java.lang.AutoCloseable接口，否则编译错误。</p>
  <p>传统的try...finally...写法关闭资源时，如果try块和finally块中都抛出异常，那么try块中的异常将被抑制（suppressed）；
  TWR则不会，原来的异常会重新抛出，而close方法抛出的异常会“被抑制”，这些异常将自动捕获，并由addSuppressed方法增加到原来的异常，可调用getSuppressed方法获取。</p>
  <p>TWR中资源是按创建顺序相反的顺序关闭的。</p>
  <p>TWR语句也可以有catch和finally块，它们将在声明的资源被关闭后运行。不过在实际中，一个try语句中加入这么多内容可能不是一个好主意。</p>
  <p>Closeable接口继承自AutoCloseable接口，前者close方法抛出IOException，后者抛出Exception。</p>
  
  <h2>final rethrow</h2>
  
  <p>有一种异常处理场景是：捕获异常仅仅为了记录日志，之后会重新抛出捕获的异常。</p>
  <p>在Java 6及之前的编译器中存在一个“缺陷”：如果捕获的是Exception或某种比实际异常类型更宽泛的异常类型，
  那么重抛的异常类型将视为这种宽泛的异常类型，而丢失了具体性。</p>
  <p>但是，Java 7的编译器可以更精确地检查重抛异常的类型，而不会丢失异常的具体性。不过，如果在catch块中给异常重新赋值，
  那么编译器将不能精确识别异常类型，而退化为之前的方式处理。</p>
  
  <h2>Lambda表达式</h2>
  
  <p>Java 8加入Lambda表达式，它不能抛出任何异常类，并且没有任何可以在其上执行异常分析的直接子表达式。包含表达式和语句的Lambda表达式体可以抛出异常类。</p>
  
  <h1>特殊说明</h1>
  
  <p>将异常声明为受检异常还是非受检异常的一条指导原则是：如果客户端可以合理地从一个异常中恢复，那么应该将异常声明为受检异常，
  否则，应该声明为非受检异常。</p>
  <p>受检异常必须服从捕获或指定要求（the Catch or Specify Requirement）。</p>
  <p>编写良好的程序应该预见并恢复受检异常。</p>
  <p>错误通常不可恢复，也不必捕获或抛出。但如果是在一个测试执行引擎中，测试脚本所抛出的错误也应在捕获范畴。</p>
  <p>运行时异常通常不可预见或恢复，并且往往它暗示程序中存在bug，比如逻辑错误或是不恰当的API使用。</p>
  
  <p>throw语句可抛出的是任意Throwable及其子类的实例，对应地，throws声明方法可能抛出的异常类型与之类似。</p>
  <p>可以在任意地方捕获RuntimeException和Exception，但受检异常只有当try块可能抛出该异常时才能捕获。</p>
  <p>如果只是把当前异常重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。
  要想更新这个信息，可以调用fillInStackTree()方法。如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。</p>
  
  <p>尽量避免在finally块中递归调用可能引起异常的方法，这将导致该方法的异常不能被正常抛出，最终被StackOverflowError掩盖。</p>
  <p>尽量避免在finally块中使用return或throw等导致方法控制权转移的语句。</p>
  
  <p class="next">涉及方法覆盖时，覆盖方法的throws子句声明可能抛出的异常应是被覆盖方法可能抛出异常的子集；
  当涉及覆盖多个接口的同一方法时，throws子句声明可能抛出的异常应是它们可能抛出异常的交集而非并集，极端情况下覆盖方法可能根本不能有throws子句。</p>
  <div class="ext">
     <p>该规定的原因在于，对于任何适用于父类或父接口（下统一简称“父类”）的方法调用，应同样适用于子类或实现类（下统一简称“子类”），这是符合父子类概念的。
     否则，如果子类方法声明的异常范围能超出父类声明的范围，那么，理应存在未处理的异常而导致编译期错误，但对于上转型或接口回调等情况下，编译期是不能对其检查的。</p>
  </div>
  
  <h2>关于执行流程</h2>
  
  <p class="next">当程序进入try块后，才可能执行catch和finally块。通常情况下，finally块是尽一切可能确保执行的，
  但是未必一定会执行，以下情况时将不会执行：</p>
  <ul>
    <li>执行try或catch块时，JVM退出（如System.exit(0)）;</li>
    <li>正在执行try或catch块的线程被中断或kill掉，即使整个程序还在继续执行。</li>
  </ul>
  <p>finally在try或catch块中存在控制转移语句时，finally块的执行情况会有一些特殊。</p>
  <p>控制转移语句包括：return、throw和break、continue，前两者将控制权转交给方法调用者，后两者控制权在方法内转移。</p>
  <p>finally块将在控制权转移前执行。对于return的返回值和throw抛出的异常，是不能在finally块中改变的，
  因为底层会将返回值及异常事先保存在本地变量表中，当finally块执行完成后再取回。</p>
  <p>此外，如果return和throw后是一个表达式，那么执行finally块前这个表达式的值会被计算。
  由于该表达式计算过程中引起的变量值的变化在执行finally块前，所以在finally块中使用这些改变了值的变量时要注意其当前值。</p>
  
  <div class="ext">
    <p class="next">如果在try或catch块中执行System.exit(0)，则由于JVM退出，从而finally块不会被执行。此时，清理工作可在如下两个地方执行：</p>
    <ul>
      <li>系统中注册的关闭钩子：Runtime.getRuntime().addShutdownHook(Thread thread)；</li>
      <li>若调用了System.runFinalizerOnExit(true)，JVM会对未结束的对象调用Finalizer。（该方法极度危险，不推荐使用）</li>
    </ul>
  </div>
  
  <h2>Java异常处理机制的优势</h2>
  
  <ol>
    <li>分组和区别错误类型；</li>
    <li>深入了解错误产生的原因，传播错误的调用栈；</li>
    <li>将错误处理代码与常规代码分离；</li>
    <li>强制用户处理特定异常（受检异常）。</li>
  </ol>
  
  <h1>惯用技巧</h1>
  
  <h2>双层捕获关闭流</h2>
  <pre class="code"><code class="java">
InputStream in = ...;
try
{
    try
    {
        // code that might throw exception
    }
    finally
    {
        in.close();
    }
}
catch(IOException e)
{
    // show error message
}  </code></pre>

  <p>说明：内层的try语句块只有一个职责，就是确保关闭输入流。
  外层的try语句块也只有一个职责，就是确保报告出现的错误。
  这种设计方式不仅清楚，而且还具有一个功能，就是将会报告 finally 子句中出现的错误。</p>
  
  <h2>抛出受检异常</h2>
  
  <pre class="code"><code class="java">
public class ThrowCheckedExceptionToUnckecked
{
    public static void main(String[] args)
    {
        doThrow(new SQLException());
    }
    
    public static void doThrow(Exception e) {
        ThrowCheckedExceptionToUnckecked.&lt;RuntimeException&gt; doThrow0(e);
    }
    
    @SuppressWarnings("unchecked")
    public static &lt;E extends Exception&gt; void doThrow0(Exception e) throws E {
        throw (E) e;
    }
}  </code></pre>

  <p>说明：对于受检异常捕获/抛出检查是由编译器进行的，而非JVM。而通过泛型的特殊应用，我们可以绕过编译器检查抛出受检异常。</p>
  
  <h1>附录</h1>
  
  <h2>定义</h2>
  
  <dl>
    <dt>异常转译</dt>
    <dd>捕获原始异常，然后抛出一个新的业务异常，新的业务异常中包含了对用户的提供信息。</dd>
  </dl>
  
  <h2>杂项</h2>
  
  <p>RuntimeException 这个名字具有迷惑性，因为，我们讨论的所有错误都发生在运行时。</p>
  
  <p>Java7几乎把所有“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口）进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口。</p>
  
</body>
</html>