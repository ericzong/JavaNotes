<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>设计模式专题：工厂方法模式（Factory Method）</title>
<link type="text/css" rel="stylesheet" href="../../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../../css/highlight.css" />

<script type="text/javascript" src="../../js/title.js"></script>
<script type="text/javascript" src="../../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>分类</h1>
  <p>对象创建型模式</p>
  
  <h1>意图</h1>
  <p>工厂方法模式（Factory Method）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。
  Factory Method 使一个类的实例化延迟到其子类。</p>
  
  <h1>别名</h1>
  <p>虚构造器（Virtual Constructor）</p>
  
  <h1>动机</h1>
  <p>框架使用抽象类定义和维护对象之间的关系。这些对象的创建通常也由框架负责。</p>
  
  <h1>适用性</h1>
  <ul>
    <li><p>当一个类不知道它所必须创建的对象的类的时候。这意味着对象的创建者只关心被创建对象的接口，而不是具体的实现。</p></li>
    <li><p>当一个类希望由它的子类来指定它所创建的对象的时候。</p></li>
    <li><p> 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p></li>
    <li><p>当创建的一组对象在未来可能存在变化的时候。</p></li>
  </ul>

  <h1>结构</h1>
  <img src="../../images/Design_Pattern_subject_factory_method.png" alt="工厂方法类图" />
  
  <h1>参与者</h1>
  <ul>
    <li>
      <p>Product</p>
      <div><p>定义工厂方法所创建的对象的接口。</p></div>
    </li>
    <li>
      <p>ConcreteProduct</p>
      <div><p>实现 Product 接口。</p></div>
    </li>
    <li>
      <p>Creator</p>
      <div>
        <p>声明工厂方法，该方法返回一个 Product 类型的对象。Creator 也可以定义一个工厂方法的缺省实现，它返回一个缺省的 ConcreteProduct 对象。</p>
        <p>可以调用工厂方法以创建一个 Product 对象。</p>
      </div>
    </li>
    <li>
      <p>ConcreteCreator</p>
      <div><p>重定义工厂方法以返回一个 ConcreteProduct 实例。</p></div>
    </li>
  </ul>
  
  <h1>协作</h1>
  <p>Creator 依赖于它的子类来定义工厂方法，所以它返回一个适当的 ConcreteProduct 实例。</p>
  
  <h1>效果</h1>
  <ol>
    <li>
      <p>工厂方法不再将与特定应用有关的类绑定到你的代码中。代码仅处理 Product 接口；因此它可以与用户定义的任何 ConcreteProduct 类一起使用。</p>
    </li>
    <li>
      <p>为子类提供挂钩（hook）。</p>
    </li>
    <li>
      <p>连接平行的类层次。</p>
      <p>当一个类将它的一些职责委托给一个独立的类的时候，就产生了平行类层次。</p>
    </li>
  </ol>
  
  <h1>实现</h1>
  <ol>
    <li>
      <p>主要有两种不同的情况。</p>
      <p>Creator 类为抽象类不提供工厂方法实现；或提供缺省实现（即使仍可能是抽象类）。</p>
    </li>
    <li><p>参数化工厂方法。</p></li>
    <li><p>特定语言的变化和问题。</p></li>
    <li><p>使用模板以避免创建子类。</p></li>
    <li><p>命名约定。</p></li>
  </ol>
  
  <h1>优缺点</h1>
  <p>优点：</p>
  <p>可以避免调用者直接创建具体的产品对象，从而解除具体产品对象与调用者之间的耦合。</p>
  <p>缺点：</p>
  <p>工厂方法的一个潜在缺点在于客户可能仅仅为了创建一个特定的 ConcreteProduct 对象，就不得不创建 Creator 的子类。</p>
  
  <h1>其它说明</h1>
  <ul>
    <li><p>简单工厂（Simple Factory）模式被视为工厂方法模式的一种特例。</p></li>
    <li>
      <p>简单工厂模式，对产品部分而言是符合开放封闭原则的，但是对工厂部分而言是不符合开放封闭原则的。
      显而易见，当新产品加入后，工厂“生产方法”需要加入新的判断逻辑。</p>
      <p>工厂方法模式，产品和工厂都符合开放封闭原则。但是，当新产品加入后，必须新建一个与之对应的具体工厂。</p>
    </li>
  </ul>
  
  <h1>相关模式</h1>
  <p>Abstract Factory 经常用工厂方法来实现。Abstract Factory 模式中动机一节的例子也对 Factory Method 进行了说明。</p>
  <p>工厂方法通常在 Template Methods 中被调用。</p>
  <p>Prototypes 不需要创建 Creator 的子类。但是，它们通常要求一个针对 Product 类的 Initialize 操作。Creator 使用 Initialize 来初始化对象。而 Factory Method 不需要这样的操作。</p>
  <p>简单工厂一般而言工厂类是一个普通的、非泛化的类，并且产品的创建方式一般为静态方法，具体地说这个静态方法一般会根据传入的参数不同创建不同的产品。</p>
  <p>工厂方法一般将工厂类泛化，并将产品的创建延迟到具体子类去实现，一般而言一个具体的工厂子类会与一种产品绑定。</p>
  <p>抽象工厂仅仅比工厂方法创建产品更为复杂，一个具体的工厂负责创建一个产品族。</p>
  
</body>
</html>