<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>设计模式专题：原型（Prototype）</title>
<link type="text/css" rel="stylesheet" href="../../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../../css/highlight.css" />

<script type="text/javascript" src="../../js/title.js"></script>
<script type="text/javascript" src="../../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>分类</h1>
  <p>对象创建型模式</p>
  
  <h1>意图</h1>
  <p>原型（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
  
  <h1>动机</h1>
  <p>减少类数目。</p>
  
  <h1>适用性</h1>
  <ul>
    <li><p>当一个系统应该独立于它的产品创建、构成和表示时。</p></li>
    <li><p>当要实例化的类是在运行时刻指定时。</p></li>
    <li><p>为了避免创建一个与产品类层次平行的工厂类层次时。</p></li>
    <li><p>当一个类的实例只能有几个不同的状态组合中的一种时，建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p></li>
  </ul>

  <h1>结构</h1>
  <img src="../../images/Design_Pattern_subject_prototype.png" alt="原型类图" />
  
  <h1>参与者</h1>
  <ul>
    <li>
      <p>Prototype</p>
      <div><p>声明一个克隆自身的接口。</p></div>
    </li>
    <li>
      <p>ConcretePrototype</p>
      <div><p>实现一个克隆自身的操作。</p></div>
    </li>
    <li>
      <p>Client</p>
      <div><p>让一个原型克隆自身从而创建一个新的对象。</p></div>
    </li>
  </ul>
  
  <h1>协作</h1>
  <p>客户请求一个原型克隆自身。</p>
  
  <h1>效果</h1>
  <ol>
    <li><p>对客户隐藏了具体的产品类，减少了客户知道的名字的数目。</p></li>
    <li><p>客户无需改变即可使用与特定应用相关的类。</p></li>
    <li><p>运行时刻增加和删除产品。</p></li>
    <li><p>改变值以指定新对象。</p></li>
    <li><p>改变结构以指定新对象。</p></li>
    <li><p>减少子类的构造。</p></li>
    <li><p>用类动态配置应用。</p></li>
    <li><p>每个 Prototype 的子类都必须实现 Clone 操作，这可能很困难。</p></li>
  </ol>
  
  <h1>实现</h1>
  <ol>
    <li><p>使用一个原型管理器。</p></li>
    <li><p>实现克隆操作。</p></li>
    <li><p>初始化克隆对象。</p></li>
  </ol>
  
  <h1>优缺点</h1>
  <p>优点：</p>
  <ol>
    <li><p>向客户隐藏制造新实例的复杂性。</p></li>
    <li><p>提供让客户能够产生未知类型对象的选项。</p></li>
    <li><p>在某些环境下，复制对象比创建新对象更有效。</p></li>
    <li><p>通过增加或者删除原型管理器中注册的对象，可以比其它创建型模式更方便的在运行时增加或者删除产品。</p></li>
  </ol>
  <p>缺点：</p>
  <p>对象的复制有时相当复杂。</p>
  
  <h1>其它说明</h1>
  <ul>
    <li><p>将具体产品的创建过程进行包装，使得客户对创建不可知。</p></li>
    <li><p>原型管理器实际上是一个工厂，不过这个工厂经过了改进，并去掉了像抽象工厂模式或者工厂方法模式那样繁多的子类。因此可以说原型模式就是在工厂模式的基础上加入了克隆方法。</p></li>
    <li><p>由于 clone 方法在 Java 实现中有着一定的弊端和风险，所以 clone 方法是不建议使用的。因此很少能在 Java 应用中看到原型模式的使用。</p></li>
  </ul>
  
  <h1>相关模式</h1>
  <p>Prototype 和 Abstract Factory 模式在某种方面是相互竞争的。但是也可以一起使用。Abstract Factory 可以存储一个被克隆的原型的集合，并返回产品对象。</p>
  <p>大量使用 Composite 和 Decorator 模式的设计通常也可以从 Prototype 模式处获益。</p>
  
</body>
</html>