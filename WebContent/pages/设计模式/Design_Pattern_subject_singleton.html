<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>设计模式专题：单例模式（Singleton）</title>
<link type="text/css" rel="stylesheet" href="../../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../../css/highlight.css" />

<script type="text/javascript" src="../../js/title.js"></script>
<script type="text/javascript" src="../../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>分类</h1>
  <p>对象创建模式</p>

  <h1>意图</h1>
  <p>单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。也称单件模式或单态模式。</p>
  
  <h1>动机</h1>
  <p>对一些类来说，只有一个实例是很重要的。</p>
  <p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。</p>

  <h1>适用性</h1>
  <p>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</p>
  <p>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p>

  <h1>结构</h1>
  <!-- 类图 -->
  <table>
    <tr>
      <th>Singleton</th>
    </tr>
    <tr>
      <td>
        <p><a class="normal notice" title="return uniqueInstance">static Instance()</a></p>
        <p>SingletonOperation()</p>
        <p>GetSingletonData()</p>
        <p>static uniqueInstance</p>
        <p>Singleton data</p>
      </td>
    </tr>
  </table>
  
  <h1>参与者</h1>
  <ul>
    <li>Singleton
      <div>
        <p>定义一个 Instance 操作，允许客户访问它的唯一实例。Instance 是一个类操作。</p>
        <p>可能负责创建它自己的唯一实例。</p>
      </div>
    </li>
  </ul>  
  
  <h1>协作</h1>
  <p>客户只能通过 Singleton 的 Instance 操作访问一个 Singleton 的实例。</p>
  
  <h1>效果</h1>
  <ol>
    <li>对唯一实例的受控访问</li>
    <li>缩小名空间</li>
    <li>允许对操作和表示的精化</li>
    <li>允许可变数目的实例</li>
    <li>比类操作更灵活</li>
  </ol>
  
  <h1>实现</h1>
  <ol>
    <li>保证一个唯一的实例</li>
    <li>创建 Singleton 类的子类</li>
  </ol>
  
  <h1>优缺点</h1>
  <p>优点：提供一个全局访问点，和全局变量一样方便，又没有全局变量的缺点。</p>
  <p>缺点：实现方式多样，特定的实现方式只能适应特定的场合。</p>
  
  <h1>其它说明</h1>
  <ul>
    <li>单例模式违反单一职责原则，该类不仅要负责类对象的创建，还要负责控制对象的个数。</li>
    <li>单例通常的特点是：构造器私有，静态持有实例对象，并以静态方法返回该实例对象。</li>
    <li>构造器私有使得类失去多态性，故也称“单态模式”。</li>
    <li>尽量避免单例模式应用于资源对象，因为某些资源不止一个，并且单例采用静态方式持有实例，无法及时释放资源。</li>
    <li>单例实现方式多样，主要根据线程安全性、急切/延迟实例化、类加载器数量等方面的要求选择不同的实现方式。</li>
    <li>单例较高级通用的实现方式有：双重检查加锁（DCL, Double-Checked Locking）和 Lazy initialization holder class。</li>
    <li>单例模式可分为有状态和无状态的。有状态的单例对象一般也是可变对象，多个单例对象在一起就可以作为状态仓库向外提供服务；
    无状态的单例对象是不可变对象，仅用做提供工具函数。</li>
  </ul>
  
  <h1>相关模式</h1>
  <p>很多模式可以使用 Singleton 模式实现。</p>
  
</body>
</html>