<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>设计模式专题：生成器模式（Builder）</title>
<link type="text/css" rel="stylesheet" href="../../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../../css/highlight.css" />

<script type="text/javascript" src="../../js/title.js"></script>
<script type="text/javascript" src="../../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>分类</h1>
  <p>对象创建型模式</p>
  
  <h1>意图</h1>
  <p>生成器模式（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>

  <h1>动机</h1>
  <p>一个 RFT（Rich Text Format）文档交换格式的阅读器应能将 RFT 转换为多种正文格式。</p>
  
  <h1>适用性</h1>
  <ul>
    <li><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</p></li>
    <li><p>当构造过程必须允许被构造的对象有不同的表示时。</p></li>
  </ul>
  
  <h1>结构</h1>
  <img src="../../images/Design_Pattern_subject_builder.png" alt="生成器类图" />
  
  <h1>参与者</h1>
  <ul>
    <li>
      <p>Builder</p>
      <div><p>为创建一个 Product 对象的各个部件指定抽象接口。</p></div>
    </li>
    <li>
      <p>ConcreteBuilder</p>
      <div>
        <p>实现 Builder 的接口以构造和装配该产品的各个部件。</p>
        <p>定义并明确它所创建的表示。</p>
        <p>提供一个检索产品的接口。</p>
      </div>
    </li>
    <li>
      <p>Director</p>
      <div>
        <p>构造一个使用 Builder 接口的对象。</p>
      </div>
    </li>
    <li>
      <p>Product</p>
      <div>
        <p>表示被构造的复杂对象。ConcreteBuilder 创建该产品的内部表示并定义它的装配过程。</p>
        <p>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p>
      </div>
    </li>
  </ul>
  
  <h1>协作</h1>
  <ul>
    <li><p>客户创建 Director 对象，并用它所想要的 Builder 对象进行配置。</p></li>
    <li><p>一旦产品部件被生成，导向器就会通知生成器。</p></li>
    <li><p>生成器处理导向器的请求，并将部件添加到该产品中。</p></li>
    <li><p>客户从生成器中检索产品。</p></li>
  </ul>
  
  <h1>效果</h1>
  <ol>
    <li><p>它使你可以改变一个产品的内部表示。</p></li>
    <li><p>它将构造代码和表示代码分开。</p></li>
    <li><p>它使你可对构造过程进行更精细的控制。</p></li>
  </ol>
  
  <h1>实现</h1>
  <p>通常有一个抽象的 Builder 类为导向者可能要求创建的每一个构件定义一个操作。这些操作缺省情况下什么都不做。
  一个 ConcreteBuilder 类对它有兴趣创建的构件重定义这些操作。</p>
  
  <h1>优缺点</h1>
  <p>优点：</p>
  <ol>
    <li><p>将一个复杂对象的创建过程封装起来。</p></li>
    <li><p>允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）。</p></li>
    <li><p>向客户隐藏产品内部的表现。</p></li>
    <li><p>产品的实现可以被替换，因为客户只看到一个抽象的接口。</p></li>
  </ol>
  <p>缺点：</p>
  <p>与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识。</p>
  
  <h1>其它说明</h1>
  <ul>
    <li><p>封装一个产品的构造过程，并允许按步骤构造。</p></li>
    <li><p>通常用来创建组合结构。</p></li>
  </ul>
  
  <h1>相关模式</h1>
  <p>Abstract Factory 与 Builder 相似，因为它也可以创建复杂对象。主要的区别是 Builder 模式着重于一步步构造一个复杂对象。
  而 Abstract Factory 着重于多个系列的产品对象（简单的或是复杂的）。Builder 在最后的一步返回产品，而对于 Abstract Factory 来说，产品是立即返回的。</p>
  <p>Composite 通常是用 Builder 生成的。</p>
  
</body>
</html>