<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>设计模式专题：适配器（Adapter）</title>
<link type="text/css" rel="stylesheet" href="../../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../../css/highlight.css" />

<script type="text/javascript" src="../../js/title.js"></script>
<script type="text/javascript" src="../../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>分类</h1>
  <p>类对象结构型模式</p>
  
  <h1>意图</h1>
  <p>适配器（Adapter）：将一个类的接口转换成客户希望的另外一个接口。
  Adapter 模式使得原本由于接口不兼容而不能一起工作的类一起工作。</p>
  
  <h1>别名</h1>
  <p>包装器（Wrapper）</p>
  
  <h1>动机</h1>
  <p>有时，为复用而设计的工具箱类不能够被复用的原因仅仅是因为它的接口与专业应用领域所需要的接口不匹配。</p>
  
  <h1>适用性</h1>
  <ul>
    <li><p>想使用一个已经存在的类，而它的接口不符合要求。</p></li>
    <li><p>想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</p></li>
    <li><p>（仅适用于对象 Adapter）想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</p></li>
  </ul>

  <h1>结构</h1>
  <p>类适配器使用多重继承对一个接口与另一个接口进行匹配。</p>
  <img src="../../images/Design_Pattern_subject_adapter.png" alt="类适配器类图" />
  <p>对象适配器依赖于对象组合。</p>
  <img  src="../../images/Design_Pattern_subject_adapter_2.png" alt="对象适配器类图" />
  
  <h1>参与者</h1>
  <ul>
    <li>
      <p>Target</p>
      <div><p>定义 Client 使用的与特定领域相关的接口。</p></div>
    </li>
    <li>
      <p>Client</p>
      <div><p>与符合 Target 接口的对象协同。</p></div>
    </li>
    <li>
      <p>Adaptee</p>
      <div><p>定义一个已存在的接口，这个接口需要适配。</p></div>
    </li>
    <li>
      <p>Adapter</p>
      <div><p>对 Adaptee 的接口与 Target 接口进行适配。</p></div>
    </li>
  </ul>
  
  <h1>协作</h1>
  <ul>
    <li><p>Client 在 Adapter 实例上调用一些操作。接着适配器调用 Adaptee 的操作实现这个请求。</p></li>
  </ul>
  
  <h1>效果</h1>
  <p>类适配器</p>
  <ul>
    <li><p>用一个具体的 Adapter 类对 Adaptee 和 Target 进行匹配。结果是当想要匹配一个类以及所有它的子类时，类 Adapter 将不能胜任工作。</p></li>
    <li><p>使得 Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。</p></li>
    <li><p>仅仅引入了一个对象，并不需要额外的指针以间接得到 adaptee。</p></li>
  </ul>
  <p>对象适配器</p>
  <ul>
    <li><p>允许一个 Adapter 与多个 Adaptee —— 即 Adaptee 本身以及它的所有子类（如果有子类的话）同时工作。Adapter 也可以一次给所有的 Adaptee 添加功能。</p></li>
    <li><p>使得重定义 Adaptee 的行为比较困难。这就需要生成 Adaptee 的子类并且使得 Adapter 引用这个子类而不是引用 Adaptee 本身。</p></li>
  </ul>
  <p>需要考虑的其他因素：</p>
  <ol>
    <li><p>Adapter 的匹配程度。</p></li>
    <li><p>可插入的 Adapter。</p></li>
    <li><p>使用双向适配器提供透明操作。</p></li>
  </ol>
  
  <h1>实现</h1>
  <p>注意的问题：</p>
  <ol>
    <li><p>使用 C++ 实现适配器类。</p></li>
    <li><p>可插入的适配器。</p></li>
  </ol>
  <p>有 3 种实现方法，它们都要为 Adaptee 找到一个“窄”接口，即可用于适配的最小操作集。</p>
  <ol>
    <li><p>使用抽象操作。</p></li>
    <li><p>使用代理对象。</p></li>
    <li><p>参数化的适配器。</p></li>
  </ol>
  
  <h1>优缺点</h1>
  <p>优点：</p>
  <p>允许客户使用新的子集合，无须改变“任何”代码。</p>
  <p>缺点：</p>
  <p>若将若干类整合在一起来提供期望的接口时，代码量较大。</p>
  
  <h1>其它说明</h1>
  <ul>
    <li><p>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。</p></li>
    <li><p>类适配器需要用到多重继承。但是，Java 不支持多继承，所以 Target 必须是接口，不可以是类。</p></li>
    <li><p>对象适配器的 Target 可以是具体或抽象的类，也可以是接口。</p></li>
    <li>
      <p>窄化/扩展适配问题。</p>
      <div class="ext">
        <p>窄化适配：将“大”的接口适配成“小”的接口是安全的，“大”接口中的多余方法将不被“调用”。</p>
        <p>扩展适配：将“小”的接口适配成“大”的接口需要注意，“小”接口不可能实现“大”接口中的多余方法，适配这些多余方法时，一般需抛出异常。</p>
      </div>
    </li>
  </ul>
  
  <h1>相关模式</h1>
  <p>模式 Bridge 的结构与对象适配器类似，但是 Bridge 模式的出发点不同：Bridge 目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。
  而 Adapter 则意味着改变一个已有对象的接口。</p>
  <p>Decorator 模式增强了其他对象的功能而同时又不改变它的接口。因此，decorate 对应用程序的透明性比适配器要好。结果是 decorator 支持递归组合，
  而纯粹使用适配器是不可能实现这一点的。</p>
  <p>模式 Proxy 在不改变它的接口的条件下，为另一个对象定义了一个代理。</p>
  
</body>
</html>