<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="author" content="Eric Zong">
<title>设计模式专题：抽象工厂（Abstract Factory）</title>
<link type="text/css" rel="stylesheet" href="../../css/common.css"  />
<link type="text/css" rel="stylesheet" href="../../css/print.css" media="print" />
<link type="text/css" rel="stylesheet" href="../../css/title.css"  />
<link type="text/css" rel="stylesheet" href="../../css/tree.css" />
<link type="text/css" rel="stylesheet" href="../../css/highlight.css" />

<script type="text/javascript" src="../../js/title.js"></script>
<script type="text/javascript" src="../../js/highlight.pack.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <h1>分类</h1>
  <p>对象创建型模式</p>
  
  <h1>意图</h1>
  <p>抽象工厂（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
  
  <h1>别名</h1>
  <p>Kit</p>
  
  <h1>动机</h1>
  <p>考虑一个支持多种视感（look-and-feel）标准的用户界面工具包。</p>
  
  <h1>适用性</h1>
  <ul>
    <li><p>一个系统要独立于它的产品的创建、组合和表示时。</p></li>
    <li><p>一个系统要由多个产品系列中的一个来配置时。</p></li>
    <li><p>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</p></li>
    <li><p>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</p></li>
  </ul>

  <h1>结构</h1>
  <img src="../../images/Design_Pattern_subject_abstract_factory.png" alt="抽象工厂类图"/>
  <img src="../../images/Design_Pattern_subject_abstract_factory_2.png" alt="产品族与产品结构">
  
  <h1>参与者</h1>
  <ul>
    <li>
      <p>AbstractFactory</p>
      <div><p>声明一个创建抽象产品对象的操作接口</p></div>
    </li>
    <li>
      <p>ConcreteFactory</p>
      <div><p>实现创建具体产品对象的操作</p></div>
    </li>
    <li>
      <p>AbstractProduct</p>
      <div><p>为一类产品对象声明一个接口</p></div>
    </li>
    <li>
      <p>ConcreteProduct</p>
      <div>
        <p>定义一个将被相应的具体工厂创建的产品对象</p>
        <p>实现 AbstractProduct 接口</p>
      </div>
    </li>
    <li>
      <p>Client</p>
      <div><p>仅使用由 AbstractFactory 和 AbstractProduct 类声明的接口</p></div>
    </li>
  </ul>
  
  <h1>协作</h1>
  <ul>
    <li>通常在运行时刻创建一个 ConcreteFactory 类的实例。这一具体的工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。</li>
    <li>AbstractFactory 将产品对象的创建延迟到它的 ConcreteFactory 子类。</li>
  </ul>
  
  <h1>效果</h1>
  <ol>
    <li><p>分离了具体的类</p></li>
    <li><p>使得易于交换产品系列</p></li>
    <li><p>有利于产品的一致性</p></li>
    <li><p>难以支持新种类的产品</p></li>
  </ol>
  
  <h1>实现</h1>
  <ol>
    <li>
      <p>将工厂作为单件</p>
      <div><p>一个应用中一般每个产品系列只需一个 ConcreteFactory 的实例。</p></div>
    </li>
    <li>
      <p>创建产品</p>
      <div>
        <p>AbstractFactory 仅声明一个创建产品的接口，真正创建产品是由 ConcreteProduct 子类实现。最通常的一个方法是为每一个产品定义一个工厂方法。
        一个具体的工厂将为每个产品重定义该工厂方法以指定产品。</p>
      </div>
    </li>
    <li>
      <p>定义可扩展的工厂</p>
      <div>
        <p>AbstractFactory 通常为每一种它可以生产的产品定义一个操作。一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。
        该参数指定了将被创建的对象的种类。它可以是一个类标识符、一个整数、一个字符串，或其他任何可以标识这种产品的东西。</p>
      </div>
    </li>
  </ol>
  
  <h1>优缺点</h1>
  <p>优点：</p>
  <ol>
    <li>具体产品从客户代码中被分离出来。</li>
    <li>容易改变产品的系列。</li>
    <li>将一个系列的产品族统一到一起创建。</li>
  </ol>
  <p>缺点：</p>
  <p>在产品族中扩展新的产品是很困难的，它需要修改抽象工厂的接口。</p>
  
  <h1>其它说明</h1>
  <ul>
    <li>可以认为抽象工厂模式是工厂方法模式的高级形式。在工厂对象中，抽象工厂模式需要创建几种产品，而每种产品的继承体系都是一致的。</li>
    <li>对于产品族而言是符合开放封闭原则的，只是在产品层次结构上是不符合的。</li>
  </ul>
  
  <h1>相关模式</h1>
  <p>AbstractFactory 类通常用工厂方法实现，但它们也可以用 Prototype 实现。</p>
  <p>一个具体的工厂通常是一个单件。</p>
  <p>简单工厂一般而言工厂类是一个普通的、非泛化的类，并且产品的创建方式一般为静态方法，具体地说这个静态方法一般会根据传入的参数不同创建不同的产品。</p>
  <p>工厂方法一般将工厂类泛化，并将产品的创建延迟到具体子类去实现，一般而言一个具体的工厂子类会与一种产品绑定。</p>
  <p>抽象工厂仅仅比工厂方法创建产品更为复杂，一个具体的工厂负责创建一个产品族。</p>
  
</body>
</html>